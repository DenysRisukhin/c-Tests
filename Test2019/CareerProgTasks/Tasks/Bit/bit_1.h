//
//  bit_1.h
//  Test2019
//
//  Created by Denys Risukhin on 2/2/20.
//  Copyright © 2020 DenysRisukhin. All rights reserved.
//

#ifndef bit_1_h
#define bit_1_h

#pragma mark - 1_1

0110 + 0010 = 1000
0011 * 0101 = 1111
0011 + 0010 = 0101
0011 * 0011 = 1001
0110 - 0011 = 0011
1101 >> 2   = 0011
1000 - 0110 = 0010
1101 ^ 0101 = 1000

0110 + 0110 = 1100
// 0110 + 0110 = 0110 * 2 - что эквивалентно смещению 0110 влево на 1

0100 * 0011 = 1100
// 0100 = 4 поэтому можно умножить 0011 на 4
// что эквивалентно сдвигу в лево на 2 бита
// тоесть 0011 сдвигает влево на 2 бита и получаем 1100

1101 ^ (~1101) = 1111
// ^ для бита и его ~ всегда 1
// поэтому a^(~a) всегда дает последовательность 1-иц

1011 & (~0 << 2) = 1000
// ~0 - это последовательность 1-иц
// ~0 << 2 - это последовательность 1-иц за которыми идут 00
// & полученного числа с другим числом сбрасывает 2 правых бита     //     этого числа

#pragma mark - 1_2

// сущ закономерность соответствия степенией 2-ки и 2-го представления числа

2^0 = 0000 0001
2^1 = 0000 0010

// используем |

(0)  0000 0000 |(2^5) 0010 0000 = 0010 0000
(32) 0010 0000 |(2^7) 1000 0000 = 1010 0000

#pragma mark - 1_3

// используем xor(исключающее или) с маской
// 1 в маске изменит бит на противоположные в независимости от предыдущего состояния
// 0 не меняет бит независимо от предыдущего состояния

101 11101 ^ 111 00000 = 010 11101

#endif /* bit_1_h */
